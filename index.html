<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>シューティングゲーム（画像版）</title>
<style>
  body { background: #001; margin: 0; overflow: hidden; text-align: center; }
  canvas { display: block; margin: 0 auto; background: #001e3c; }
  /* ゲームオーバー時のボタン */
  #restartBtn {
    display: none;
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    background: #28a745;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
  }
  #restartBtn:hover {
    background: #218838;
  }
</style>
</head>
<body>
<canvas id="game" width="480" height="640"></canvas>

<!-- やり直しボタン -->
<button id="restartBtn">やり直す</button>

<!-- BGM用audioタグ -->
<audio id="bgm" src="MEGALOVANIA.wav" loop></audio>
<audio id="loseBgm" src="ケツイ.wav"></audio>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const PLAYER_SIZE = { w: 50, h: 50 };
const ENEMY_SIZE = { w: 40, h: 40 };
const BULLET_SIZE = { w: 10, h: 20 };

let keys = {};
let score = 0;
let missed = 0;
let gameover = false;

// player画像
const playerImgs = [new Image(), new Image(), new Image(), new Image()];
playerImgs[0].src = "player0.png";
playerImgs[1].src = "player1.png";
playerImgs[2].src = "player2.png";
playerImgs[3].src = "player3.png";

// enemy画像
const enemyImgs = [new Image(), new Image(), new Image(), new Image()];
enemyImgs[0].src = "enemy0.png";
enemyImgs[1].src = "enemy1.png";
enemyImgs[2].src = "enemy2.png";
enemyImgs[3].src = "enemy3.png";

class Player {
  constructor() {
    this.x = canvas.width / 2 - PLAYER_SIZE.w/2;
    this.y = canvas.height - PLAYER_SIZE.h - 10;
    this.width = PLAYER_SIZE.w;
    this.height = PLAYER_SIZE.h;
    this.speed = 5;
    this.hp = 3;
    this.invincibleTimer = 0;
    this.imgIndex = 1;
  }
  move() {
    if (keys["ArrowLeft"] && this.x > 0) this.x -= this.speed;
    if (keys["ArrowRight"] && this.x + this.width < canvas.width) this.x += this.speed;
  }
  draw() {
    ctx.save();
    if(this.invincibleTimer > 0){
      ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 100);
    }
    ctx.drawImage(playerImgs[this.imgIndex], this.x, this.y, this.width, this.height);
    ctx.restore();
  }
  takeDamage() {
    if (this.invincibleTimer === 0) {
      this.hp--;
      this.invincibleTimer = 60;
    }
  }
  update() {
    if (this.invincibleTimer > 0) this.invincibleTimer--;
  }
}

class Bullet {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.width = BULLET_SIZE.w;
    this.height = BULLET_SIZE.h;
    this.speed = 10;
  }
  move() { this.y -= this.speed; }
  draw() {
    ctx.fillStyle = "yellow";
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
  isOffscreen() { return this.y + this.height < 0; }
  getRect() { return {x:this.x, y:this.y, width:this.width, height:this.height}; }
}

class Enemy {
  constructor(x, y, hp=2, imgIndex=1) {
    this.x = x;
    this.y = y;
    this.width = ENEMY_SIZE.w;
    this.height = ENEMY_SIZE.h;
    this.speed = 3;
    this.hp = hp;
    this.hitFlashTimer = 0;
    this.imgIndex = imgIndex;
  }
  move() { this.y += this.speed; }
  draw() {
    ctx.save();
    if(this.hitFlashTimer > 0){ ctx.globalAlpha = 0.7; }
    ctx.drawImage(enemyImgs[this.imgIndex], this.x, this.y, this.width, this.height);
    ctx.restore();
    if(this.hitFlashTimer > 0) this.hitFlashTimer--;
  }
  takeDamage() { this.hp--; this.hitFlashTimer = 5; }
  getRect() { return {x:this.x, y:this.y, width:this.width, height:this.height}; }
  isOffscreen() { return this.y > canvas.height; }
}

function rectsCollide(r1, r2) {
  return !(r2.x > r1.x + r1.width || 
           r2.x + r2.width < r1.x || 
           r2.y > r1.y + r1.height || 
           r2.y + r2.height < r1.y);
}

let player;
let bullets;
let enemies;
let spacePressed;

function initGame(){
  player = new Player();
  bullets = [];
  enemies = [];
  score = 0;
  missed = 0;
  gameover = false;
  spacePressed = false;
  document.getElementById("restartBtn").style.display = "none";
  gameLoop();
}

function getCurrentLevel(){
  if(score >= 40) return 3;
  if(score >= 20) return 2;
  return 1;
}

function spawnEnemy() {
  const x = Math.random() * (canvas.width - ENEMY_SIZE.w);
  const level = getCurrentLevel();
  let hp = 1;
  if(level === 1) hp = 1;
  else if(level === 2) hp = 2;
  else if(level === 3) hp = 3;

  enemies.push(new Enemy(x, -ENEMY_SIZE.h, hp, level));
}

function update() {
  if(gameover) return;

  player.move();
  player.imgIndex = getCurrentLevel();

  if(keys[" "] || keys["Spacebar"]){
    if(bullets.length < 5 && !spacePressed) {
      bullets.push(new Bullet(player.x + player.width/2 - BULLET_SIZE.w/2, player.y));
      spacePressed = true;
    }
  } else {
    spacePressed = false;
  }

  bullets.forEach((b,i) => {
    b.move();
    if(b.isOffscreen()) bullets.splice(i,1);
  });

  if(Math.random() < 0.02){ spawnEnemy(); }

  enemies.forEach((e,i) => {
    e.move();
    if(e.isOffscreen()){ enemies.splice(i,1); missed++; }
  });

  bullets.forEach((b, bi) => {
    enemies.forEach((e, ei) => {
      if(rectsCollide(b.getRect(), e.getRect())){
        bullets.splice(bi,1);
        e.takeDamage();
        if(e.hp <= 0){
          enemies.splice(ei,1);
          score++;
        }
      }
    });
  });

  enemies.forEach((e, ei) => {
    if(rectsCollide(player, e.getRect())){
      player.takeDamage();
      enemies.splice(ei,1);
    }
  });

  player.update();

  if(player.hp <= 0 || missed >= 3){
    gameover = true;
    player.imgIndex = 0;
    enemies.forEach(e => e.imgIndex = 0);

    // BGM切り替え
    const bgm = document.getElementById("bgm");
    const loseBgm = document.getElementById("loseBgm");
    bgm.pause();
    bgm.currentTime = 0;
    loseBgm.currentTime = 0;
    loseBgm.play();

    document.getElementById("restartBtn").style.display = "inline-block";
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  player.draw();
  bullets.forEach(b => b.draw());
  enemies.forEach(e => e.draw());

  ctx.fillStyle = "white";
  ctx.font = "20px sans-serif";
  ctx.fillText(`HP: ${player.hp}`, 10, 30);
  ctx.fillText(`Score: ${score}`, 10, 60);
  ctx.fillStyle = "salmon";
  ctx.fillText(`Missed: ${missed}/3`, 10, 90);

  if(gameover){
    ctx.fillStyle = "red";
    ctx.font = "50px sans-serif";
    ctx.fillText("GAME OVER", canvas.width/2 - 130, canvas.height/2);
  }
}

function gameLoop() {
  update();
  draw();
  if(!gameover){
    requestAnimationFrame(gameLoop);
  }
}

window.onload = () => {
  const bgm = document.getElementById("bgm");
  bgm.volume = 0.5;
  bgm.play().catch(() => {
    console.log("自動再生が制限されています。");
  });
  initGame();
};

window.addEventListener("keydown", e => {
  keys[e.key] = true;
  const bgm = document.getElementById("bgm");
  if(bgm.paused && !gameover){ bgm.play(); }
});
window.addEventListener("keyup", e => {
  keys[e.key] = false;
});

document.getElementById("restartBtn").addEventListener("click", () => {
  const bgm = document.getElementById("bgm");
  const loseBgm = document.getElementById("loseBgm");
  loseBgm.pause();
  loseBgm.currentTime = 0;
  bgm.currentTime = 0;
  bgm.play();
  initGame();
});
</script>
</body>
</html>
